<html>

<head>
  <title>Demo</title>
  <script type="text/javascript" src="src/grout.js"></script>
</head>

<style>

#content {
	text-align: center;
}
canvas {
	align: center;
	border: 1px solid red;
}

</style>

<body>

<div id='content'>

<script>

function pallette() {

	// http://stackoverflow.com/questions/57803/how-to-convert-decimal-to-hex-in-javascript
	function decimalToHex(d, padding) {

		var hex = Number(d).toString(16);		
		padding = typeof (padding) === "undefined" || padding === null ? padding = 2 : padding;

		while (hex.length < padding) {
			hex = "0" + hex;
		}

		return hex;
	}

	var grout = []

    for (r = 0; r < 16; r++) {

		// create new screen
		grout[r] = new Grout({
			'canvas_id': 'pallette_' + r,
			'width': 16,
			'height': 16
		});

		for (g = 0; g < 16; g++) {
			for (b = 0; b < 16; b++) {

				red   = decimalToHex(r * 16);
				green = decimalToHex(g * 16);
				blue  = decimalToHex(b * 16);

				color = '#' + red + green + blue;
				//alert(grout[r]);
				grout[r].pixels[g][b] = color;
			}
		}

		// draw pallette
		grout[r].draw();

		// add color display
		document.write('<p><input id="color_' + r + '"></p>');

		// store value of r for reference in click logic
		grout[r].r = r;

		// set click logic
		grout[r].click(function (x, y) {
			this.doc_get('color_' + this.r).setAttribute('value', this.pixels[x][y]);
		});
    }
}

function demo() {

	// create new grout
	var grout = new Grout({
		'width': 300,
		'height': 300
	});

	// create pixel map
	map = grout.map('face');
	map.pixels[1][1] = true;
	map.pixels[3][1] = true;
	map.poke(1, 4);
	map.poke([[2, 5], [3, 4]]);

	// set click logic for pixel map
	map.click(function (x, y) {

		// toggle virtual pixel
		this.toggle(x, y);

		// refresh pixel display
		this.draw();
	});

	// create pixel map
	map = grout.map('dot');
	map.pixels[0][0] = true;

	// ad-hoc map state info can be stored in the state hash
	map.state['x'] = 0;

	// set global click logic
	grout.click(function (x, y) {

		// global click gets real pixel coordinates
		alert('You clicked x=' + x + ', y=' + y);
	});

	// animation loop
	grout.animate(100, function () {

		//
		// animate face
		//

		var face = this.maps['face']

		// "zoom" in
		face.pixel_height = face.pixel_width = (face.pixel_width < 50) ?
			face.pixel_width + 1 : 1;

		// open mouth in fear
		face.pixels[2][3] = face.pixel_width > 30 ? true : false;

		// flash eyes
		face.pixels[1][1] = face.pixels[3][1] = !face.pixels[3][1];

		//
		// animate dot
		//
		
		var dot = this.maps['dot'];

		//alert('-1:' + dot.pixels[0][0]);
		dot.shift(1, 0);
		//alert(dot.pixels[1][0]);

		//dot.pixels[dot.state['x']][0] = false
		//dot.state['x'] = dot.state['x'] < 9 ? dot.state['x'] + 1 : 1;
		//dot.pixels[dot.state['x']][0] = true
	});
}

function groutris() {

	var pixel_width = 10;
	var pixel_map_width = 10;
	var canvas_width = pixel_width * pixel_map_width;

	// create new grout
	var grout = new Grout({
		'width': canvas_width,
		'height': canvas_width
	});

	grout.state['turns'] = 0;

	// create pixel map for background
	var background = grout.map('background');

	// create pixel map for game pieces
	var piece = grout.map('piece');

	// game piece generation logic
	function generate_piece() {

		var piece = [];

		piece[0] = [];
		piece[0][0] = true;
		piece[0][1] = true;
		piece[1] = [];
		piece[1][0] = true;
		piece[1][1] = true;		

		return piece;
	}

	// restart logic
	function restart(background, piece) {

		background.clear();
	
		// generate game piece
		piece.overwrite(generate_piece());
		
		grout.draw_all();
	}

	// set up game
	restart(background, piece);

	// set up keyboard handling
	grout.keypress(function(key) {

		var margin_space;
		var response;
		var will_collide_with_background;

		var keycode_response = {
			37: {
				'shift_x': -1,
				'shift_y': 0,
				'margin_check_function': 'margin_left'
			},
			39: {
				'shift_x': 1,
				'shift_y': 0,
				'margin_check_function': 'margin_right'
			},
			40: {
				'shift_x': 0,
				'shift_y': 1,
				'margin_check_function': 'margin_bottom'
			}
		}

		for (keycode in keycode_response) {

			response = keycode_response[keycode];

			// execute appropriate piece method to check space between piece and map edge
			margin_space = piece[response['margin_check_function']]();

			// check to see if piece, when shifted, would collide with the background
			will_collide_with_background = piece.check_if_shift_will_collide_with_pixels(
				response['shift_x'],
				response['shift_y'],
				background.pixels
			)

			// shift piece if key is pressed and there is space to shift it to
			if (key == keycode
			  && margin_space != 0
			  && !will_collide_with_background
			) {
				piece.shift(response['shift_x'], response['shift_y']);
			}
			else if (key == keycode && keycode == 39) {
				//piece.margin_horizontal(true);
				//alert('MS:' + margin_space);
				//alert('PWC:' + piece.check_if_shift_will_collide_with_pixels(1, 0, background.pixels));
			}
		}
	});

	// enter main loop
	grout.animate(100, function () {

		this.state['turns']++;

		/*
		// cycle through stack of shifts to try, then apply
		for (shift as shift_schedule) {
			alert('SX:' + shift['x'] +/SY:' + shift['y']);
		}
		// empty stack
		*/

		if (this.state['turns'] % 10 == 0) {

			piece = this.maps['piece'];

			if (piece.margin_bottom() != 0
			  && !piece.check_if_shift_will_collide_with_pixels(0, 1, background.pixels)) {
				piece.shift(0, 1);
			}
			else {

				// add piece to background
				background.stamp(piece.pixels);

				// if piece that has just dropped is at top of map, end game
				if (piece.margin_top() == 0) {

					alert('Game over');

					restart(background, piece);
				}
				else {
		
					// generate game piece
					piece.overwrite(generate_piece());
				}
			}
		}
	});
}

//demo();
//pallette()
groutris();

</script>

</div id='content'>

</body>
</html>
